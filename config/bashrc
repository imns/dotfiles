 export PATH=~/bin:/usr/local/bin:/usr/local/mysql/bin:usr/local/deployd/bin:/opt/local/bin:/opt/local/sbin:$PATH

#for django and heroku
export LOCAL_DEV=true
export NODE_DEV_ENV=true

#oracle
export ORACLE_HOME=/usr/local/lib/instantclient
export LD_LIBRARY_PATH=$ORACLE_HOME:$LD_LIBRARY_PATH
export DYLD_LIBRARY_PATH=$ORACLE_HOME
export VERSIONER_PYTHON_PREFER_64_BIT=yes
export VERSIONER_PYTHON_PREFER_32_BIT=no

#aliases
alias folders='find . -maxdepth 1 -type d -print0 | xargs -0 du -sk | sort -rn'

#more aliases
if [ -f ~/.bash_aliases ]; then
  . ~/.bash_aliases
fi


#git push
gpush(){
  BRANCH=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
  MSG=$1
  if [ "$MSG" ]; then
	   git add . && git commit -am "$MSG" && git push origin $BRANCH
  else
	   echo "Please enter a commit message"
  fi
}

#git pull origin {{branch}}
gpull(){
 BRANCH=$(git branch | sed -n -e 's/^\* \(.*\)/\1/p')
 git pull origin $BRANCH
}

#fabric autocomplete
_fab(){
    local cur
    COMPREPLY=()
    # Variable to hold the current word
    cur="${COMP_WORDS[COMP_CWORD]}"

    # Build a list of the available tasks using the command 'fab -l'
    local tags=$(fab -l 2>/dev/null | grep "^ " | awk '{print $1;}')

    # Generate possible matches and store them in the
    # array variable COMPREPLY
    COMPREPLY=($(compgen -W "${tags}" $cur))
}

# Assign the auto-completion function _fab for our command fab.
complete -F _fab fab

#go up n # of dirs
up(){
  local d=""
  limit=$1
  for ((i=1 ; i <= limit ; i++))
    do
      d=$d/..
    done
  d=$(echo $d | sed 's/^\///')
  if [ -z "$d" ]; then
    d=..
  fi
  cd $d
}

#search for strings on uncommented Python lines
#ex: pygrep "search_string_here" optional_list_of_files_and_directories
function pygrep () { grep -r --exclude="*.pyc" --exclude="*.swp" ^[^#]*$1.* ${@:2}; }

#extracts all kinds of zip type files
extract () {
   if [ -f $1 ] ; then
       case $1 in
           *.tar.bz2)   tar xvjf $1    ;;
           *.tar.gz)    tar xvzf $1    ;;
           *.bz2)       bunzip2 $1     ;;
           *.rar)       unrar x $1       ;;
           *.gz)        gunzip $1      ;;
           *.tar)       tar xvf $1     ;;
           *.tbz2)      tar xvjf $1    ;;
           *.tgz)       tar xvzf $1    ;;
           *.zip)       unzip $1       ;;
           *.Z)         uncompress $1  ;;
           *.7z)        7z x $1        ;;
           *)           echo "don't know how to extract '$1'..." ;;
       esac
   else
       echo "'$1' is not a valid file!"
   fi
 }

test -r /sw/bin/init.sh && . /sw/bin/init.sh


#pretty colors
function prompt {

  local BLACK="\[\033[0;30m\]"
  local BLACKBOLD="\[\033[1;30m\]"
  local RED="\[\033[0;31m\]"
  local REDBOLD="\[\033[1;31m\]"
  local GREEN="\[\033[0;32m\]"
  local GREENBOLD="\[\033[1;32m\]"
  local YELLOW="\[\033[0;33m\]"
  local YELLOWBOLD="\[\033[1;33m\]"
  local BLUE="\[\033[0;34m\]"
  local BLUEBOLD="\[\033[1;34m\]"
  local PURPLE="\[\033[0;35m\]"
  local PURPLEBOLD="\[\033[1;35m\]"
  local CYAN="\[\033[0;36m\]"
  local CYANBOLD="\[\033[1;36m\]"
  local WHITE="\[\033[0;37m\]"
  local WHITEBOLD="\[\033[1;37m\]"

  __git_ps1() {
    local b="$(git symbolic-ref HEAD 2>/dev/null)";
    if [ -n "$b" ]; then
        printf " (%s)" "${b##refs/heads/}";
    fi
  }

  ## enable fancy git prompt if possible
  if [ "$(type -t __git_ps1)" == "function" ]; then
    gitsection="$BOLD_ON$RED\$(__git_ps1 '(%s)')"
  else
    gitsection=""
  fi

  prefix=${debian_chroot:+($debian_chroot)}

export PS1="\n$GREENBOLD \u\[\033[00m\]: $CYAN\w\[\033[00m\] ${gitsection}\[\033[00m\] \\$ "
}
prompt


#ssh stuff from github
SSH_ENV="$HOME/.ssh/environment"
